[{"title":"机器学习实战 读书笔记 01 第一章","url":"/2020/11/07/20201107-skt-01/","content":"\n#### 前言\n这个系列是AI“四大名著”之一《机器学习实战：基于 Scikit-Learn、Keras 和 TensorFlow（第二版）》的读书笔记系列，主要记录阅读过程中的知识点和一些思考。\n\n#### 第1章 机器学习概览\n\n1. 机器学习的定义\n    一个计算机程序利用经验E来学习任务T，性能是P，如果针对任务T的性能P随着经验E不断增长，则称为机器学习。——Tom Mitchell 1997\n    感觉这个说法也出现在了很多其他的教材里，也十分的工程化。就是针对任务T，通过经验E，寻求性能P的提升。\n    \n    \n2. 为什么使用机器学习\n    与这个问题相对应的是：什么样的问题适合用机器学习来解决。主要包括以下几种：\n    - 有解决方案的问题，但是可以通过机器学习算法来简化代码，或提升性能（书中给出的例子是垃圾邮件过滤，传统方法需要手工设计大量的规则来加以判断，且难以维护）\n    - 传统方法难以解决的复杂问题(比如同音单词识别)\n    - 环境有波动，适应新数据\n    - 洞察复杂问题和大量数据，挖掘数据中的规律\n    \n    \n3. 机器学习的类型\n<table>\n    <tr>\n        <th>分类依据</th>\n        <th>类别</th>\n        <th>特点</th>\n        <th>具体算法或备注</th>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">有无监督信号</td>\n        <td>监督学习</td>\n        <td>提供了包含解决方案(标签/label/ground truth)的训练集，主要包含分类和回归两大类</td>\n        <td><li>k-近邻</li><li>线性回归</li><li>逻辑回归</li><li>SVM</li><li>决策树和随机森林</li></td>\n    </tr>\n    <tr>\n        <td>无监督学习</td>\n        <td>所有训练数据均未标记，主要包含聚类、异常检测和新颖性检测、可视化和降维、关联规则学习</td>\n        <td><li>聚类：k-means、DBSCAN、分层聚类分析HCA</li>\n        <li>异常检测和新颖性检测：单类SVM、孤立森林</li>\n        <li>可视化和降维：主成分分析(PCA)、核主成分分析、局部线性嵌入(LLE)、t-分布随机近邻嵌入(t-SNE)</li>\n        <li>关联规则学习：Apriori、Eclat</li></td>\n    </tr>\n    <tr>\n        <td>半监督学习</td>\n        <td>少量有标记数据和大量未标记数据，通常是有监督和无监督算法的组合</td>\n        <td><li>深度信念网络DBN</li></td>\n    </tr>\n    <tr>\n        <td>强化学习</td>\n        <td>通过观察环境，做出选择，执行动作，得到回报（或惩罚）</td>\n        <td><li>Q-learning</li><li>Sarsa</li></td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">是否进行增量学习</td>\n        <td>批量学习</td>\n        <td>离线进行训练后，部署至生存环境，因此是在完整数据集上训练；遇到新的数据后，需要在新的完整数据集上重新训练，停用旧系统，启用新系统。 </td>\n        <td>缺点：耗时占资源，每次训练需要完整数据集训练几个小时，且完整数据集训练需要大量计算资源</td>\n    </tr>\n    <tr>\n        <td>在线学习</td>\n        <td>可以根据新数据进入不断学习调整模型，每次只学习新数据，完成后即可丢弃数据</td>\n        <td><li>核外学习：针对超大数据集，存储在不同计算机上，每次只加载部分数据进行学习，直至完成整个数据集训练，这个过程通常是<font color=#0087BB>离线</font>的</li><li>在线学习: 由于模型需要根据新数据进行调整，则需要设置学习率，来决定适应新数据（忘记旧数据）的速度，同时也要求<font color=#0087BB>监控异常数据</font></li></td>\n    </tr>\n    <tr>\n        <td rowspan=\"2\">模型泛化模式</td>\n        <td>基于实例的学习</td>\n        <td>记住学过的所有数据，将新数据与已学过的数据进行比对，根据相似度来给出预测结果</td>\n        <td>需要选择多少个最近邻的实例</td>\n    </tr>\n    <tr>\n        <td>基于模型的学习</td>\n        <td>通过数据构建相应的模型（找出数据中的规律），然后根据模型对新数据进行预测</td>\n        <td>超参数：模型的复杂度；参数：训练过程的求解结果；目标函数：训练过程中的优化目标</td>\n    </tr>\n</table>\n\n\n4. 机器学习的主要挑战及解决方法\n    - 数据问题\n        - 数据数量不足：构建更大的数据集\n        - 数据不具有代表性（采样偏差）：改进采样方法\n        - 低质量数据（噪声、错误和异常值等）：丢弃异常值，忽略/修复缺失的部分特征\n        - 无关特征：特征选择，特征提取，收集新数据\n    - 训练过程\n        - 过拟合：选择更小参数的模型/减少数据中的属性数量/约束模型（正则化）；收集更多数据；减少数据中的噪声\n        - 欠拟合：选择更多参数的模型；提供更好的特征集（更加容易学习）；减少模型中的约束    \n   \n   \n5. 测试与验证\n    - 测试集：为了确保模型在生产环境中的可靠性，将数据集分割成训练集和测试集，用测试集来评估模型。\n    - 验证集(dev/val set)：如果选出测试集表现最好的模型，则可能是对测试集部分的过拟合，实际环境中表现不如预期。因此从训练集中再分割出一部分作为验证集，用验证集来挑选模型，测试集来评估模型。\n    - 训练开发集合(train-dev set)：在数据缺乏的情况下，可以采用其他相近数据来代替，但是由于数据来源不同，可能出现训练集测试集<font color=#0087BB>数据不匹配(mismatch)</font>的情况，因此将真实场景数据划分为验证集和测试集，而训练集数据划分为训练集和训练开发集（验证集）：\n        - 如果在训练开发集表现较差，代表模型过拟合；\n        - 如果在训练开发集表现较好，而验证集表现差，则问题来自数据不匹配，需要对数据进行处理。 ","tags":["读书笔记","机器学习"],"categories":["reading_notes"]},{"title":"Python学习笔记01 \"is\" 和 \"==\" 的区别","url":"/2020/10/12/20201012-python-01/","content":"\n\n#### `is` 和 \"==\" 的概念\n`==`比较的是两个对象的“值“是否相等\n`is`比较的是两个对象在内存中的地址是否相同（值相等，内存一致，可以理解为`id(a) == id(b)`）\n\n\n**代码示例**\n```python\na = 19260817\nb = 19260817\nc = a \nprint(a == b)\n# 数值一致, 返回True\nprint(a is b)\n# 地址不一致, 返回False\nprint(a == c)\n# 数值一致, 返回True\nprint(a is c)\n# 地址一致, 返回True\n```\n<!-- more -->\n####其他关于`is`的注意事项：\n- 为了提升性能, python将<font color=#0087BB>$[-5, 256]$</font>区间内的整数放在了`small_ints`中,需要用到的时候直接从里面取值, 而不是创造新的对象, 因此区间内的对象只要数值相同, 他们的地址也相同。\n- 类似的, 为了提高字符串利用效率, python使用了intern(字符串驻留)机制, 将<font color=#0087BB>长度不超过20, 且仅由下划线、数字、字母组成的字符串</font>以`{string: id(string)}`的字典形式存储, 相同字符串使用同一个地址。(在`Pycharm`和`VS code`等IDE中, 只要字符串<font color=#0087BB>长度不超过20</font>, 就会采用上述形式存储。)\n- 和`None`比较时使用`is`, `None`也是有专门的地址, 因此只要变量是`None`, 均是同一个地址。\n\n**代码示例**\n```python    \na = 52\nb = 52\nprint(a is b)\n# 数值在[-5, 256]区间内, 返回True\n\na = 520\nb = 520\nprint(a is b)\n# 数值不在[-5, 256]区间内, 返回False\n\na = \"ab\"\nb = \"ab\"\nprint(a is b)\n# 满足`intern`机制要求, 返回True\n\na = \"a b\"\nb = \"a b\"\nprint(a is b)\n# 不一定满足`intern`机制要求, 在python终端中返回False, Pycharm中返回True\n\na = \"\"\nprint(a is None)\n# a是字符串对象, 有自己的地址, 返回False\n\nb = None\nprint(b is None)\n# 返回True\n```\n\n参考资料：\nhttps://blog.csdn.net/qq_26442553/article/details/82195061\nhttps://www.cnblogs.com/greatfish/p/6045088.html","tags":["python"],"categories":["techs"]},{"title":"算法学习001  树的概念与常见算法 01","url":"/2020/09/28/20200928-alg-01-tree-01/","content":"\n###树的定义\n>树(Tree)是$n(n\\ge0)$个结点(node)的有限集。在任意一个非空树中：\n>1. 有且只有一个特定的称为根(Root)的结点；\n>2. 当$n > 1$时，其余结点可分为$m(m>0)$个互不相交的有限集，每个集合本身又是一棵树，称为根节点的子树。$^{[1]}$\n\n以下图为例，$1$ 号结点为根节点，其余结点可以划分为$3$ 个互不相交的集合，每个集合都是一棵树，分别为$[2, 5]$, $[3, 6, 7]$, $[4, 8, 9, 10, 11]$。\n\n\n![树](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_01.png)\n\n这棵树可以理解为带有多个$next$指针的链表，例如$3$ 号结点后面有$2$个$next$指针，分别指向结点$6$和结点$7$。\n\n如果树中每个结点的子树不超过$2$棵，并且$2$棵子树有左右之分，则把这种树称为二叉树。为了方便讨论，同时考虑到大量的算法题也是基于也是针对后面以二叉树为主，因此后续以二叉树作为讨论对象。\n\n<!-- more -->\n\n在`LeetCode`中，二叉树的`C++` 和 `Python`结构如下：\n```C++\n/* C++ 下的二叉树结构体*/\nstruct TreeNode\n{\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr){}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr){}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right){}\n};\n```\n\n```python\n# python下的二叉树类\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n```\n这里也画了二叉树的结构，左右子树各一个指针，指向自己的子树。这个结构本身就具有递归的性质，因此很多相应的问题可以用递归的思路来解决。\n![二叉树](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_02.png)\n\n###二叉树的性质\n1. 二叉树第$i$层最多有$2^{i-1}$个结点（根节点记为第一层，即$i\\geq1$）\n2. 高度为$k$的二叉树，最多拥有$2^k-1$个结点($k\\geq1$,计算过程：$num_{node}\\leq1+2+4+...+2^{k-1}=2^k-1$  )\n3. 根据性质2可以倒推，拥有$n$个结点的二叉树，高度最少为$log_2(n+1)$\n4. 在任意二叉树下，一共有$n$个结点，$n-1$条边，若叶子结点个数记为$n_0$，有一个孩子的结点(对应一条边)个数为$n_1$，两个孩子结点(对应两条边)的个数记为$n_2$，则可以得出$n_0+n_1+n_2(结点数量) = 2\\times n_2+n_1(边的数量)+1$，整理可以得到$n_0 = n_2 + 1$，主要会在选择题中考察。\n![二叉树结构](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_03.png)\n\n###树的遍历\n\n![二叉树遍历](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_04.png)\n\n[1]严蔚敏, 吴伟民. 清华大学计算机系列教材 :数据结构[M]// 清华大学计算机系列教材 ：数据结构. 清华大学出版社, 2011.","tags":["树","算法"],"categories":["algorithms"]},{"title":"detectron2 源码阅读系列 02 Demo.py","url":"/2020/09/10/20200911-detectron2-02-demo/","content":"\n上一篇通过`demo.py`运行得到了一个检测的结果，这次深入到demo文件夹中，分析整体框架的搭建。该文件夹一共有两个文件，分别是`demo.py` 和`predictor.py`，核心功能就是通过获取运行参数中的输入，进行结果预测，并输出可视化结果。\n\n`demo.py`的调用关系如下图所示\n\n![demo结构](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/20200911_demo_frame.png)\n\n<!-- more -->\n\n###demo.py 文件概览\n\n文件主要包含三个函数\n\n- 主函数\n- `get_parser()`\n- `setup_cfg(args)`\n\n#### 主函数\n\n总体流程\n\n1. `multiprocessing.set_start_method()`设置多线程操作\n2. 自定义的`get_parser()` 函数获取参数，存入`args` \n3. 自定义的`setup_logger()`函数设置日志文件\n4. 使用`logger.info()` 记录参数信息\n5. 自定义的`setup_cfg(arg)` 将获取的参数进行设置，存入`cfg`\n6. 创建<font color=#0087BB>`VisualizationDemo`</font>类的实例为<font color=#0087BB>`demo`</font>\n7. 如果输入是图像`(args.input)`\n   1. 如果输入时单张图片，确认指定路径下的文件存在\n   2. 遍历`args.input`:\n      1. 使用`read_image()`读取路径下的图片\n      2. 记录开始时间\n      3. 调用<font color=#0087BB>`demo.run_on_image`</font>得到预测结果`predictions`和可视化结果`visualized_output`，并记录日志信息（`predictions`预测到多少实例，预测花费时间）\n      4. 如果需要保存结果，则将可视化结果进行保存至`args.output`\n      5. 否则利用窗口进行展示，按`esc`键退出\n8. 如果输入是网络摄像头`(args.webcam)`:\n   1. 确认不包含图片输入`args.input`，且没有输出参数`args.output`\n   2. 设置摄像头为`cam`，并在上面运行<font color=#0087BB>`demo.run_on_video`</font>\n   3. 针对每帧图片的预测结果，窗口显示1ms，按`esc`键退出，退出后释放网络摄像头，关闭所有窗口\n9. 如果输入是视频`(args.video_input)`\n   1. 将视频读进`video`，获取视频的尺寸信息`width`和`height`, 帧率`frames_per_second`，总帧数`num_frams`，\n   2. 在`video`上运行<font color=#0087BB>`demo.run_on_video`</font>，如果需要输出，则写入`output_file`，否则通过窗口显示结果，按`esc`键退出。运行后释放输入输出视频，关闭所有窗口。\n\n\n####  参数解析的`get_parser()` 函数\n\n这个函数的核心功能是利用系统的`argparse`模块进行参数解析，主要创建`ArgumentParser`对象，调用`.add_argument()`方法定义参数，使用`.parse_args()`进行参数解析三个步骤。第三个步骤在主函数里面调用，因此这个函数核心代码就只包含对象创建以及添加参数，最后返回`ArgumentParser`对象。\n\n```python\ndef get_parser():\n    parser = argparse.ArgumentParser()\n    parser.add_argument()\n```\n\n这里添加的参数有\n- `--config-file` 配置文件位置\n- `--webcam` 网络摄像头\n- `--video-input` 视频路径\n- `--input` 输入图片路径\n- `--output` 可视化结果输出位置，如果为赋值，则通过窗口显示\n- `--confidence-threshold` 显示实例预测的最小阈值\n- `--opts` 其他可选配置\n\n####  `setup_cfg(args)`函数\n\n前面`get_parser()` 函数返回的是一个参数解析器，主函数调用`.parse_args()`进行参数解析后得到`args`是一个`namespace`，指定了对应的配置文件，还需要将配置文件的参数进行解析。\n\n首先构建了一个默认的`CfgNode`对象，主要用来存放基本的网络参数配置，通过调用`.merge_from_file()` 和 `.merge_from_list()`两个方法解析`args`的指定的配置文件，对默认数值进行更新。\n\n***\n\n###  `Predictor.py`文件概览\n\n从上面的总体流程中可以看出，`demo.py`的核心功能是通过<font color =#0087BB>`VisualizationDemo`</font> 类实现的，这个类在同目录下的`predictor.py` 文件中。这个文件内部主要包含两个类：\n- `VisualizationDemo`\n\n- `AsyncPredictor`  \n\n\n#### `VisualizationDemo` 类\n\n内部定义了以下四个函数：\n- `__init__()`\n- `run_on_image()`\n- `run_on_video()`\n- `_frame_from_video()`\n\n\t##### `__init__()`\n\t定义了预测参数，并根据并行处理需求将`predictor`设置为默认预测器`DefaultPredictor`或者并行预测器`AsyncPredictor`。\n\n\t##### `run_on_image(self, image)`\n\n\t- 输入：图像（H, W, C）图像模式 (BGR)\n\t- 输出：网络输出结果`predictions`, 可视化结果`vis_output`，可视化结果是`Visualizer`对象。\n\n\t##### `_frame_from_video(self, video)`\n\t获取视频帧\n\n\t##### `run_on_video(self, video)`\n\t调用`_frame_from_video` 方法获取视频帧，对每一帧进行预测，并通过内置的`process_predictions`方法，创建`Visualizer`对象，对结果进行展示。\n\n\t#### `AsyncPredictor`类\n\t主要是针对多GPU预测进行了处理，每个GPU上构建一个默认预测器`DefaultPredictor`，分别进行预测。\n\n### `DefaultPredictor` 类\n\n不论是单GPU，还是多GPU，最后的预测器都调用了`DefaultPredictor` 类，该类位于`detectron2\\engine\\defaults.py`中，内部只有初始化函数`__init__`和回调函数`__call__`，核心功能是通过给定参数构建端到端的网络，对输入图像进行`Transfrom`后，并送入网络模型，预测结果。\n\ndemo的功能浏览完了，接下去的内容会从`Dataloader`开始，构建模型，评估测试，最终结果可视化。","tags":["深度学习","pytorch","源码阅读","目标检测","框架学习"],"categories":["codes"]},{"title":"detectron2 源码阅读系列 01 安装流程","url":"/2020/09/10/20200910-detectron2-01-installation/","content":"\n####前言\n[Detectron2](https://github.com/facebookresearch/detectron2) 是Facebook AI Research (FAIR)开源的目标检测框架，在上一代的基础上，基于Pytorch进行了实现。模型涵盖目标检测的Faster R-CNN, RetinaNet, 实例分割的Mask R-CNN, 关键点估计的Dense Pose, 全景分割的Panoptic FPN等多个模型，以及相应数据的加载等。\n\n最近在自己的项目实现过程，深刻意识到设计一个系统与解决一道代码题目是两个不同的概念。正好项目中需要用到Detectron2的部分代码，因此将Detectron2作为自己学习代码规范和项目实现的样例。\n\n<!-- more -->\n\n###主机环境\n\n| 名称  | 版本  |\n|:-------: | :--------:|\n|操作系统|Linux 16.04|\n|显卡\t|GTX Titan X|\n|驱动\t|418.56\t\t|\n|CUDA|9.0\t\t|\n|Conda|4.84\t\t|\n\n###安装过程\n逐行运行下列命令即可，按照[官方文档](https://detectron2.readthedocs.io/tutorials/install.html)运行的时候，发现少了`opencv-python`库，因此补了一条。\n\n```\nconda create -n detectron2 python=3.6\nconda activate detectron2\nconda install pytorch torchvision cudatoolkit=9.2 -c pytorch\npip install opencv-python\ngit clone https://github.com/facebookresearch/detectron2.git\npython -m pip install -e detectron2\n```\n\n###Demo测试\n####数据准备\n提前找一张图片放进`demo`文件夹中，这里从[网络](http://www.gudaimi.com/Sjfyltu/201812/99590.html)随机照了一张图片，保存的文件名为 `test_pic.jpg`，结果并保存为同目录下的` res_pic.jpg` (`--output` 后的参数)；如果要测试视频，输出参数要将`--input` 改为`--video-input`。其余参数可以使用`python demo.py -h` 进行查看。\n\n####代码运行\n进入`demo`文件夹测试\n\n```\ncd dtectron2/demo\npython demo.py --config-file ../configs/COCO- InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml \\\n--input test_pic.jpg --output res_pic.jpg --opts MODEL.WEIGHTS \\\ndetectron2://COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x/137849600/model_final_f10217.pkl\n```\n\n#####输入\n![输入图像](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/test_pic.jpeg)\n\n#####结果\n![测试结果](http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/res_pic.jpg)\n\n到这里就完成了Detectron2的全部安装过程了，明天开始阅读demo.py文件。","tags":["深度学习","pytorch","源码阅读","目标检测","框架学习"],"categories":["codes"]},{"title":"蝉鸣低语","url":"/2020/06/30/2020060-gossip-001/","content":"\n## 引子\n\n十七年的蛰伏，只为一个盛夏，只为这个盛夏。\n\n无人的深夜，从地下钻出。这并不是第一次看见这个世界，上一次不过是十七年前，出生后的匆匆一瞥。现在，依旧无暇关注，因为还有更重要的事情等着我。爬上树梢，准备开启生命中的最后一个阶段。在原来的身体里挣扎着，感受着躯壳撕裂开来，一点一点的剥离开来。相同的事情，已经经历了四次，现如今看着褪下的身躯，感叹着这是最后一次了，终于到最后一次了，梦想化作双翼。至此，总算拥有了生命，与灵魂契合的生命。\n\n<!-- more -->\n\n## 缘起\n\n自己的身份证快要过期了，下一张的有效期便是二十年。大哥自成年之后，即将走上奔三的生涯。终于是到了这个失去的年纪，不论是自己的亲人，抑或是崇拜的偶像，从霍金到张守晟，从金庸到斯坦·李，那些为人类科学事业不断奉献的人，那些伴随着自己成长的角色，终究都成了过往。\n\n自从大学毕业之后，时间过得飞快。不记得哪一天开始，不怎么找歌听了，觉得现在列表里的就不错。也追不上新番了，仿佛中二病，黑子的篮球还是去年的番，夏目友人帐第五季，也不过是刚出的消息。最近买来的游戏，静静的躺在那里，看完了游戏启动画面，就再也没有然后。或许只是出于情怀喜+1吧，半开玩笑的说着“自己花钱买的游戏，凭什么还要花时间玩”，心里却多少有些落寞。遇到事情，不论好坏，也不愿去多谈什么，只是默默放在心底。\n\n回首过去，才发觉忙忙碌碌，却什么都没有做。学了很多，却又什么都没有记住。人生实苦，于我而言，生命本身是没有意义的，更多的是寻找意义的过程，以及这一生中，不论悲喜，给自己留下的感觉。\n\n未来，我如果有一个孩子，我不指望他能达成多大的成就，不求大富大贵，不求功名显赫。但是我想在灿烂星河下讲着牛郎织女的故事，说着奥林匹斯山上众神的纷争，告诉他阿基米德撬动地球的支点，以及梵高笔下的星夜。希望他能够领略浩瀚宇宙中的美景，更希望他能够被那一段段深情的文字所打动，为科学的公式所折服，为艺术的升华所感染。在万家灯火中，体验人间冷暖，学会感恩，懂得体谅。终于，他觉得无愧此生，平静坦然地按自己的计划过完余生。\n\n可是孩子终究是独立的个体，本不应该按照我设定的路线走下去。这个世界，有太多的不如意，带他来到这个世界，或许就已经亏欠他太多了。直到朋友说起，这可能也是你想成为的人吧。那一刻，才意识到，原来这是自己想要成为的样子啊。自己终究不能免俗，将自己未完成的事情，寄希望于自己的孩子，更可笑的是自己还不自知。又或许是自己早早的框定了自己的余生，已经没有去戍守边疆，保家卫国，若是用尽全力，去做一些事情，做成一些事情，就很好了。\n\n关于余生，我总需要一个出口。筹划了很久的博客，总算在今年提上了日程，记下人间的美好，存下自己的呢喃，也为自己的盛夏蛰伏。故此，蝉鸣。","tags":["人间值得"],"categories":["thoughts"]}]