<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YvesXu</title>
  
  <subtitle>技术 · 生活 · 人间值得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yvesxu.com/"/>
  <updated>2020-11-08T00:32:44.384Z</updated>
  <id>http://www.yvesxu.com/</id>
  
  <author>
    <name>YvesXu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习实战 读书笔记 01 第一章</title>
    <link href="http://www.yvesxu.com/2020/11/07/20201107-skt-01/"/>
    <id>http://www.yvesxu.com/2020/11/07/20201107-skt-01/</id>
    <published>2020-11-07T07:58:55.000Z</published>
    <updated>2020-11-08T00:32:44.384Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h4><p>这个系列是AI“四大名著”之一《机器学习实战：基于 Scikit-Learn、Keras 和 TensorFlow（第二版）》的读书笔记系列，主要记录阅读过程中的知识点和一些思考。</p><h4 id="1-第1章-机器学习概览"><a href="#1-第1章-机器学习概览" class="headerlink" title="1. 第1章 机器学习概览"></a>1. 第1章 机器学习概览</h4><h5 id="1-1-机器学习的定义"><a href="#1-1-机器学习的定义" class="headerlink" title="1.1 机器学习的定义"></a>1.1 机器学习的定义</h5><pre><code>一个计算机程序利用经验E来学习任务T，性能是P，如果针对任务T的性能P随着经验E不断增长，则称为机器学习。——Tom Mitchell 1997感觉这个说法也出现在了很多其他的教材里，也十分的工程化。就是针对任务T，通过经验E，寻求性能P的提升。</code></pre><h5 id="1-2-为什么使用机器学习"><a href="#1-2-为什么使用机器学习" class="headerlink" title="1.2 为什么使用机器学习"></a>1.2 为什么使用机器学习</h5><pre><code>与这个问题相对应的是：什么样的问题适合用机器学习来解决。主要包括以下几种：- 有解决方案的问题，但是可以通过机器学习算法来简化代码，或提升性能（书中给出的例子是垃圾邮件过滤，传统方法需要手工设计大量的规则来加以判断，且难以维护）- 传统方法难以解决的复杂问题(比如同音单词识别)- 环境有波动，适应新数据- 洞察复杂问题和大量数据，挖掘数据中的规律</code></pre><h5 id="1-3-机器学习的类型"><a href="#1-3-机器学习的类型" class="headerlink" title="1.3 机器学习的类型"></a>1.3 机器学习的类型</h5><table>    <tr>        <th>分类依据</th>        <th>类别</th>        <th>特点</th>        <th>具体算法或备注</th>    </tr>    <tr>        <td rowspan="4">有无监督信号</td>        <td>监督学习</td>        <td>提供了包含解决方案(标签/label/ground truth)的训练集，主要包含分类和回归两大类</td>        <td><li>k-近邻</li><li>线性回归</li><li>逻辑回归</li><li>SVM</li><li>决策树和随机森林</li></td>    </tr>    <tr>        <td>无监督学习</td>        <td>所有训练数据均未标记，主要包含聚类、异常检测和新颖性检测、可视化和降维、关联规则学习</td>        <td><li>聚类：k-means、DBSCAN、分层聚类分析HCA</li>        <li>异常检测和新颖性检测：单类SVM、孤立森林</li>        <li>可视化和降维：主成分分析(PCA)、核主成分分析、局部线性嵌入(LLE)、t-分布随机近邻嵌入(t-SNE)</li>        <li>关联规则学习：Apriori、Eclat</li></td>    </tr>    <tr>        <td>半监督学习</td>        <td>少量有标记数据和大量未标记数据，通常是有监督和无监督算法的组合</td>        <td><li>深度信念网络DBN</li></td>    </tr>    <tr>        <td>强化学习</td>        <td>通过观察环境，做出选择，执行动作，得到回报（或惩罚）</td>        <td><li>Q-learning</li><li>Sarsa</li></td>    </tr>    <tr>        <td rowspan="2">是否进行增量学习</td>        <td>批量学习</td>        <td>离线进行训练后，部署至生存环境，因此是在完整数据集上训练；遇到新的数据后，需要在新的完整数据集上重新训练，停用旧系统，启用新系统。 </td>        <td>缺点：耗时占资源，每次训练需要完整数据集训练几个小时，且完整数据集训练需要大量计算资源</td>    </tr>    <tr>        <td>在线学习</td>        <td>可以根据新数据进入不断学习调整模型，每次只学习新数据，完成后即可丢弃数据</td>        <td><li>核外学习：针对超大数据集，存储在不同计算机上，每次只加载部分数据进行学习，直至完成整个数据集训练，这个过程通常是<font color=#0087BB>离线</font>的</li><li>在线学习: 由于模型需要根据新数据进行调整，则需要设置学习率，来决定适应新数据（忘记旧数据）的速度，同时也要求<font color=#0087BB>监控异常数据</font></li></td>    </tr>    <tr>        <td rowspan="2">模型泛化模式</td>        <td>基于实例的学习</td>        <td>记住学过的所有数据，将新数据与已学过的数据进行比对，根据相似度来给出预测结果</td>        <td>需要选择多少个最近邻的实例</td>    </tr>    <tr>        <td>基于模型的学习</td>        <td>通过数据构建相应的模型（找出数据中的规律），然后根据模型对新数据进行预测</td>        <td>超参数：模型的复杂度；参数：训练过程的求解结果；目标函数：训练过程中的优化目标</td>    </tr></table><h5 id="1-4-机器学习的主要挑战及解决方法"><a href="#1-4-机器学习的主要挑战及解决方法" class="headerlink" title="1.4 机器学习的主要挑战及解决方法"></a>1.4 机器学习的主要挑战及解决方法</h5><pre><code>- 数据问题    - 数据数量不足：构建更大的数据集    - 数据不具有代表性（采样偏差）：改进采样方法    - 低质量数据（噪声、错误和异常值等）：丢弃异常值，忽略/修复缺失的部分特征    - 无关特征：特征选择，特征提取，收集新数据- 训练过程    - 过拟合：选择更小参数的模型/减少数据中的属性数量/约束模型（正则化）；收集更多数据；减少数据中的噪声    - 欠拟合：选择更多参数的模型；提供更好的特征集（更加容易学习）；减少模型中的约束    </code></pre><h5 id="1-5-测试与验证"><a href="#1-5-测试与验证" class="headerlink" title="1.5 测试与验证"></a>1.5 测试与验证</h5><pre><code>- 测试集：为了确保模型在生产环境中的可靠性，将数据集分割成训练集和测试集，用测试集来评估模型。- 验证集(dev/val set)：如果选出测试集表现最好的模型，则可能是对测试集部分的过拟合，实际环境中表现不如预期。因此从训练集中再分割出一部分作为验证集，用验证集来挑选模型，测试集来评估模型。- 训练开发集合(train-dev set)：在数据缺乏的情况下，可以采用其他相近数据来代替，但是由于数据来源不同，可能出现训练集测试集&lt;font color=#0087BB&gt;数据不匹配(mismatch)&lt;/font&gt;的情况，因此将真实场景数据划分为验证集和测试集，而训练集数据划分为训练集和训练开发集（验证集）：    - 如果在训练开发集表现较差，代表模型过拟合；    - 如果在训练开发集表现较好，而验证集表现差，则问题来自数据不匹配，需要对数据进行处理。 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h4&gt;&lt;p&gt;这个系列是AI“四大名著”之一《机器学习实战：基于 Scikit-Learn、Keras 和 TensorFlow（第二
      
    
    </summary>
    
    
      <category term="reading_notes" scheme="http://www.yvesxu.com/categories/reading-notes/"/>
    
    
      <category term="读书笔记" scheme="http://www.yvesxu.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://www.yvesxu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记01 &quot;is&quot; 和 &quot;==&quot; 的区别</title>
    <link href="http://www.yvesxu.com/2020/10/12/20201012-python-01/"/>
    <id>http://www.yvesxu.com/2020/10/12/20201012-python-01/</id>
    <published>2020-10-12T05:23:15.000Z</published>
    <updated>2020-11-08T00:31:42.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-is-和-“-”-的概念"><a href="#1-is-和-“-”-的概念" class="headerlink" title="1. is 和 “==” 的概念"></a>1. <code>is</code> 和 “==” 的概念</h4><p><code>==</code>比较的是两个对象的“值“是否相等<br><code>is</code>比较的是两个对象在内存中的地址是否相同（值相等，内存一致，可以理解为<code>id(a) == id(b)</code>）</p><p><strong>代码示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">19260817</span></span><br><span class="line">b = <span class="number">19260817</span></span><br><span class="line">c = a </span><br><span class="line">print(a == b)</span><br><span class="line"><span class="comment"># 数值一致, 返回True</span></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 地址不一致, 返回False</span></span><br><span class="line">print(a == c)</span><br><span class="line"><span class="comment"># 数值一致, 返回True</span></span><br><span class="line">print(a <span class="keyword">is</span> c)</span><br><span class="line"><span class="comment"># 地址一致, 返回True</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p><h4 id="2-其他关于is的注意事项："><a href="#2-其他关于is的注意事项：" class="headerlink" title="2. 其他关于is的注意事项："></a>2. 其他关于<code>is</code>的注意事项：</h4><ul><li>为了提升性能, python将<font color=#0087BB>$[-5, 256]$</font>区间内的整数放在了<code>small_ints</code>中,需要用到的时候直接从里面取值, 而不是创造新的对象, 因此区间内的对象只要数值相同, 他们的地址也相同。</li><li>类似的, 为了提高字符串利用效率, python使用了intern(字符串驻留)机制, 将<font color=#0087BB>长度不超过20, 且仅由下划线、数字、字母组成的字符串</font>以<code>&#123;string: id(string)&#125;</code>的字典形式存储, 相同字符串使用同一个地址。(在<code>Pycharm</code>和<code>VS code</code>等IDE中, 只要字符串<font color=#0087BB>长度不超过20</font>, 就会采用上述形式存储。)</li><li>和<code>None</code>比较时使用<code>is</code>, <code>None</code>也是有专门的地址, 因此只要变量是<code>None</code>, 均是同一个地址。</li></ul><p><strong>代码示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">52</span></span><br><span class="line">b = <span class="number">52</span></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 数值在[-5, 256]区间内, 返回True</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">520</span></span><br><span class="line">b = <span class="number">520</span></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 数值不在[-5, 256]区间内, 返回False</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;ab&quot;</span></span><br><span class="line">b = <span class="string">&quot;ab&quot;</span></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 满足`intern`机制要求, 返回True</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;a b&quot;</span></span><br><span class="line">b = <span class="string">&quot;a b&quot;</span></span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 不一定满足`intern`机制要求, 在python终端中返回False, Pycharm中返回True</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;&quot;</span></span><br><span class="line">print(a <span class="keyword">is</span> <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># a是字符串对象, 有自己的地址, 返回False</span></span><br><span class="line"></span><br><span class="line">b = <span class="literal">None</span></span><br><span class="line">print(b <span class="keyword">is</span> <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 返回True</span></span><br></pre></td></tr></table></figure></p><p>参考资料：<br><a href="https://blog.csdn.net/qq_26442553/article/details/82195061">https://blog.csdn.net/qq_26442553/article/details/82195061</a><br><a href="https://www.cnblogs.com/greatfish/p/6045088.html">https://www.cnblogs.com/greatfish/p/6045088.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-is-和-“-”-的概念&quot;&gt;&lt;a href=&quot;#1-is-和-“-”-的概念&quot; class=&quot;headerlink&quot; title=&quot;1. is 和 “==” 的概念&quot;&gt;&lt;/a&gt;1. &lt;code&gt;is&lt;/code&gt; 和 “==” 的概念&lt;/h4&gt;&lt;p&gt;&lt;code&gt;==&lt;/code&gt;比较的是两个对象的“值“是否相等&lt;br&gt;&lt;code&gt;is&lt;/code&gt;比较的是两个对象在内存中的地址是否相同（值相等，内存一致，可以理解为&lt;code&gt;id(a) == id(b)&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;19260817&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = &lt;span class=&quot;number&quot;&gt;19260817&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c = a &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a == b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 数值一致, 返回True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 地址不一致, 返回False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a == c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 数值一致, 返回True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 地址一致, 返回True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="techs" scheme="http://www.yvesxu.com/categories/techs/"/>
    
    
      <category term="python" scheme="http://www.yvesxu.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>算法学习001  树的概念与常见算法 01</title>
    <link href="http://www.yvesxu.com/2020/09/28/20200928-alg-01-tree-01/"/>
    <id>http://www.yvesxu.com/2020/09/28/20200928-alg-01-tree-01/</id>
    <published>2020-09-28T04:20:30.000Z</published>
    <updated>2020-11-08T00:33:13.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-树的定义"><a href="#1-树的定义" class="headerlink" title="1. 树的定义"></a>1. 树的定义</h3><blockquote><p>树(Tree)是$n(n\ge0)$个结点(node)的有限集。在任意一个非空树中：</p><ol><li>有且只有一个特定的称为根(Root)的结点；</li><li>当$n &gt; 1$时，其余结点可分为$m(m&gt;0)$个互不相交的有限集，每个集合本身又是一棵树，称为根节点的子树。$^{[1]}$</li></ol></blockquote><p>以下图为例，$1$ 号结点为根节点，其余结点可以划分为$3$ 个互不相交的集合，每个集合都是一棵树，分别为$[2, 5]$, $[3, 6, 7]$, $[4, 8, 9, 10, 11]$。</p><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_01.png" alt="树"></p><p>这棵树可以理解为带有多个$next$指针的链表，例如$3$ 号结点后面有$2$个$next$指针，分别指向结点$6$和结点$7$。</p><p>如果树中每个结点的子树不超过$2$棵，并且$2$棵子树有左右之分，则把这种树称为二叉树。为了方便讨论，同时考虑到大量的算法题也是基于也是针对后面以二叉树为主，因此后续以二叉树作为讨论对象。</p><a id="more"></a><p>在<code>LeetCode</code>中，二叉树的<code>C++</code> 和 <code>Python</code>结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++ 下的二叉树结构体*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python下的二叉树类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=None, right=None</span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure><p>这里也画了二叉树的结构，左右子树各一个指针，指向自己的子树。这个结构本身就具有递归的性质，因此很多相应的问题可以用递归的思路来解决。<br><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_02.png" alt="二叉树"></p><h3 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="2. 二叉树的性质"></a>2. 二叉树的性质</h3><ol><li>二叉树第$i$层最多有$2^{i-1}$个结点（根节点记为第一层，即$i\geq1$）</li><li>高度为$k$的二叉树，最多拥有$2^k-1$个结点($k\geq1$,计算过程：$num_{node}\leq1+2+4+…+2^{k-1}=2^k-1$  )</li><li>根据性质2可以倒推，拥有$n$个结点的二叉树，高度最少为$log_2(n+1)$</li><li>在任意二叉树下，一共有$n$个结点，$n-1$条边，若叶子结点个数记为$n_0$，有一个孩子的结点(对应一条边)个数为$n_1$，两个孩子结点(对应两条边)的个数记为$n_2$，则可以得出$n_0+n_1+n_2(结点数量) = 2\times n_2+n_1(边的数量)+1$，整理可以得到$n_0 = n_2 + 1$，主要会在选择题中考察。<br><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_03.png" alt="二叉树结构"></li></ol><h3 id="3-树的遍历"><a href="#3-树的遍历" class="headerlink" title="3. 树的遍历"></a>3. 树的遍历</h3><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_04.png" alt="二叉树遍历"></p><p>[1]严蔚敏, 吴伟民. 清华大学计算机系列教材 :数据结构[M]// 清华大学计算机系列教材 ：数据结构. 清华大学出版社, 2011.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-树的定义&quot;&gt;&lt;a href=&quot;#1-树的定义&quot; class=&quot;headerlink&quot; title=&quot;1. 树的定义&quot;&gt;&lt;/a&gt;1. 树的定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;树(Tree)是$n(n\ge0)$个结点(node)的有限集。在任意一个非空树中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有且只有一个特定的称为根(Root)的结点；&lt;/li&gt;
&lt;li&gt;当$n &amp;gt; 1$时，其余结点可分为$m(m&amp;gt;0)$个互不相交的有限集，每个集合本身又是一棵树，称为根节点的子树。$^{[1]}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下图为例，$1$ 号结点为根节点，其余结点可以划分为$3$ 个互不相交的集合，每个集合都是一棵树，分别为$[2, 5]$, $[3, 6, 7]$, $[4, 8, 9, 10, 11]$。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/alg/20200928_tree_01.png&quot; alt=&quot;树&quot;&gt;&lt;/p&gt;
&lt;p&gt;这棵树可以理解为带有多个$next$指针的链表，例如$3$ 号结点后面有$2$个$next$指针，分别指向结点$6$和结点$7$。&lt;/p&gt;
&lt;p&gt;如果树中每个结点的子树不超过$2$棵，并且$2$棵子树有左右之分，则把这种树称为二叉树。为了方便讨论，同时考虑到大量的算法题也是基于也是针对后面以二叉树为主，因此后续以二叉树作为讨论对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithms" scheme="http://www.yvesxu.com/categories/algorithms/"/>
    
    
      <category term="树" scheme="http://www.yvesxu.com/tags/%E6%A0%91/"/>
    
      <category term="算法" scheme="http://www.yvesxu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>detectron2 源码阅读系列 02 Demo.py</title>
    <link href="http://www.yvesxu.com/2020/09/10/20200911-detectron2-02-demo/"/>
    <id>http://www.yvesxu.com/2020/09/10/20200911-detectron2-02-demo/</id>
    <published>2020-09-10T14:12:52.000Z</published>
    <updated>2020-11-08T00:33:49.966Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇通过<code>demo.py</code>运行得到了一个检测的结果，这次深入到demo文件夹中，分析整体框架的搭建。该文件夹一共有两个文件，分别是<code>demo.py</code> 和<code>predictor.py</code>，核心功能就是通过获取运行参数中的输入，进行结果预测，并输出可视化结果。</p><p><code>demo.py</code>的调用关系如下图所示</p><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/20200911_demo_frame.png" alt="demo结构"></p><a id="more"></a><h3 id="1-demo-py-文件概览"><a href="#1-demo-py-文件概览" class="headerlink" title="1. demo.py 文件概览"></a>1. demo.py 文件概览</h3><p>文件主要包含三个函数</p><ul><li>主函数</li><li><code>get_parser()</code></li><li><code>setup_cfg(args)</code></li></ul><h4 id="1-1-主函数"><a href="#1-1-主函数" class="headerlink" title="1.1 主函数"></a>1.1 主函数</h4><p>总体流程</p><ol><li><code>multiprocessing.set_start_method()</code>设置多线程操作</li><li>自定义的<code>get_parser()</code> 函数获取参数，存入<code>args</code> </li><li>自定义的<code>setup_logger()</code>函数设置日志文件</li><li>使用<code>logger.info()</code> 记录参数信息</li><li>自定义的<code>setup_cfg(arg)</code> 将获取的参数进行设置，存入<code>cfg</code></li><li>创建<font color=#0087BB><code>VisualizationDemo</code></font>类的实例为<font color=#0087BB><code>demo</code></font></li><li>如果输入是图像<code>(args.input)</code><ol><li>如果输入时单张图片，确认指定路径下的文件存在</li><li>遍历<code>args.input</code>:<ol><li>使用<code>read_image()</code>读取路径下的图片</li><li>记录开始时间</li><li>调用<font color=#0087BB><code>demo.run_on_image</code></font>得到预测结果<code>predictions</code>和可视化结果<code>visualized_output</code>，并记录日志信息（<code>predictions</code>预测到多少实例，预测花费时间）</li><li>如果需要保存结果，则将可视化结果进行保存至<code>args.output</code></li><li>否则利用窗口进行展示，按<code>esc</code>键退出</li></ol></li></ol></li><li>如果输入是网络摄像头<code>(args.webcam)</code>:<ol><li>确认不包含图片输入<code>args.input</code>，且没有输出参数<code>args.output</code></li><li>设置摄像头为<code>cam</code>，并在上面运行<font color=#0087BB><code>demo.run_on_video</code></font></li><li>针对每帧图片的预测结果，窗口显示1ms，按<code>esc</code>键退出，退出后释放网络摄像头，关闭所有窗口</li></ol></li><li>如果输入是视频<code>(args.video_input)</code><ol><li>将视频读进<code>video</code>，获取视频的尺寸信息<code>width</code>和<code>height</code>, 帧率<code>frames_per_second</code>，总帧数<code>num_frams</code>，</li><li>在<code>video</code>上运行<font color=#0087BB><code>demo.run_on_video</code></font>，如果需要输出，则写入<code>output_file</code>，否则通过窗口显示结果，按<code>esc</code>键退出。运行后释放输入输出视频，关闭所有窗口。</li></ol></li></ol><h4 id="1-2-参数解析的get-parser-函数"><a href="#1-2-参数解析的get-parser-函数" class="headerlink" title="1.2 参数解析的get_parser() 函数"></a>1.2 参数解析的<code>get_parser()</code> 函数</h4><p>这个函数的核心功能是利用系统的<code>argparse</code>模块进行参数解析，主要创建<code>ArgumentParser</code>对象，调用<code>.add_argument()</code>方法定义参数，使用<code>.parse_args()</code>进行参数解析三个步骤。第三个步骤在主函数里面调用，因此这个函数核心代码就只包含对象创建以及添加参数，最后返回<code>ArgumentParser</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument()</span><br></pre></td></tr></table></figure><p>这里添加的参数有</p><ul><li><code>--config-file</code> 配置文件位置</li><li><code>--webcam</code> 网络摄像头</li><li><code>--video-input</code> 视频路径</li><li><code>--input</code> 输入图片路径</li><li><code>--output</code> 可视化结果输出位置，如果为赋值，则通过窗口显示</li><li><code>--confidence-threshold</code> 显示实例预测的最小阈值</li><li><code>--opts</code> 其他可选配置</li></ul><h4 id="1-3-setup-cfg-args-函数"><a href="#1-3-setup-cfg-args-函数" class="headerlink" title="1.3 setup_cfg(args)函数"></a>1.3 <code>setup_cfg(args)</code>函数</h4><p>前面<code>get_parser()</code> 函数返回的是一个参数解析器，主函数调用<code>.parse_args()</code>进行参数解析后得到<code>args</code>是一个<code>namespace</code>，指定了对应的配置文件，还需要将配置文件的参数进行解析。</p><p>首先构建了一个默认的<code>CfgNode</code>对象，主要用来存放基本的网络参数配置，通过调用<code>.merge_from_file()</code> 和 <code>.merge_from_list()</code>两个方法解析<code>args</code>的指定的配置文件，对默认数值进行更新。</p><hr><h3 id="2-Predictor-py文件概览"><a href="#2-Predictor-py文件概览" class="headerlink" title="2. Predictor.py文件概览"></a>2. <code>Predictor.py</code>文件概览</h3><p>从上面的总体流程中可以看出，<code>demo.py</code>的核心功能是通过<font color =#0087BB><code>VisualizationDemo</code></font> 类实现的，这个类在同目录下的<code>predictor.py</code> 文件中。这个文件内部主要包含两个类：</p><ul><li><p><code>VisualizationDemo</code></p></li><li><p><code>AsyncPredictor</code>  </p></li></ul><h4 id="2-1-VisualizationDemo-类"><a href="#2-1-VisualizationDemo-类" class="headerlink" title="2.1 VisualizationDemo 类"></a>2.1 <code>VisualizationDemo</code> 类</h4><p>内部定义了以下四个函数：</p><ul><li><code>__init__()</code></li><li><code>run_on_image()</code></li><li><code>run_on_video()</code></li><li><p><code>_frame_from_video()</code></p><h5 id="init"><a href="#init" class="headerlink" title="__init__()"></a><code>__init__()</code></h5><p>  定义了预测参数，并根据并行处理需求将<code>predictor</code>设置为默认预测器<code>DefaultPredictor</code>或者并行预测器<code>AsyncPredictor</code>。</p><h5 id="run-on-image-self-image"><a href="#run-on-image-self-image" class="headerlink" title="run_on_image(self, image)"></a><code>run_on_image(self, image)</code></h5><ul><li>输入：图像（H, W, C）图像模式 (BGR)</li><li><p>输出：网络输出结果<code>predictions</code>, 可视化结果<code>vis_output</code>，可视化结果是<code>Visualizer</code>对象。</p><h5 id="frame-from-video-self-video"><a href="#frame-from-video-self-video" class="headerlink" title="_frame_from_video(self, video)"></a><code>_frame_from_video(self, video)</code></h5><p>获取视频帧</p><h5 id="run-on-video-self-video"><a href="#run-on-video-self-video" class="headerlink" title="run_on_video(self, video)"></a><code>run_on_video(self, video)</code></h5><p>调用<code>_frame_from_video</code> 方法获取视频帧，对每一帧进行预测，并通过内置的<code>process_predictions</code>方法，创建<code>Visualizer</code>对象，对结果进行展示。</p><h4 id="AsyncPredictor类"><a href="#AsyncPredictor类" class="headerlink" title="AsyncPredictor类"></a><code>AsyncPredictor</code>类</h4><p>主要是针对多GPU预测进行了处理，每个GPU上构建一个默认预测器<code>DefaultPredictor</code>，分别进行预测。</p></li></ul></li></ul><h3 id="3-DefaultPredictor-类"><a href="#3-DefaultPredictor-类" class="headerlink" title="3. DefaultPredictor 类"></a>3. <code>DefaultPredictor</code> 类</h3><p>不论是单GPU，还是多GPU，最后的预测器都调用了<code>DefaultPredictor</code> 类，该类位于<code>detectron2\engine\defaults.py</code>中，内部只有初始化函数<code>__init__</code>和回调函数<code>__call__</code>，核心功能是通过给定参数构建端到端的网络，对输入图像进行<code>Transfrom</code>后，并送入网络模型，预测结果。</p><p>demo的功能浏览完了，接下去的内容会从<code>Dataloader</code>开始，构建模型，评估测试，最终结果可视化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇通过&lt;code&gt;demo.py&lt;/code&gt;运行得到了一个检测的结果，这次深入到demo文件夹中，分析整体框架的搭建。该文件夹一共有两个文件，分别是&lt;code&gt;demo.py&lt;/code&gt; 和&lt;code&gt;predictor.py&lt;/code&gt;，核心功能就是通过获取运行参数中的输入，进行结果预测，并输出可视化结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;demo.py&lt;/code&gt;的调用关系如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/20200911_demo_frame.png&quot; alt=&quot;demo结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="codes" scheme="http://www.yvesxu.com/categories/codes/"/>
    
    
      <category term="深度学习" scheme="http://www.yvesxu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://www.yvesxu.com/tags/pytorch/"/>
    
      <category term="源码阅读" scheme="http://www.yvesxu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="目标检测" scheme="http://www.yvesxu.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="框架学习" scheme="http://www.yvesxu.com/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>detectron2 源码阅读系列 01 安装流程</title>
    <link href="http://www.yvesxu.com/2020/09/10/20200910-detectron2-01-installation/"/>
    <id>http://www.yvesxu.com/2020/09/10/20200910-detectron2-01-installation/</id>
    <published>2020-09-10T01:25:24.000Z</published>
    <updated>2020-11-08T00:34:42.603Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h4><p><a href="https://github.com/facebookresearch/detectron2">Detectron2</a> 是Facebook AI Research (FAIR)开源的目标检测框架，在上一代的基础上，基于Pytorch进行了实现。模型涵盖目标检测的Faster R-CNN, RetinaNet, 实例分割的Mask R-CNN, 关键点估计的Dense Pose, 全景分割的Panoptic FPN等多个模型，以及相应数据的加载等。</p><p>最近在自己的项目实现过程，深刻意识到设计一个系统与解决一道代码题目是两个不同的概念。正好项目中需要用到Detectron2的部分代码，因此将Detectron2作为自己学习代码规范和项目实现的样例。</p><a id="more"></a><h3 id="1-主机环境"><a href="#1-主机环境" class="headerlink" title="1. 主机环境"></a>1. 主机环境</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">版本</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:center">Linux 16.04</td></tr><tr><td style="text-align:center">显卡</td><td style="text-align:center">GTX Titan X</td></tr><tr><td style="text-align:center">驱动</td><td style="text-align:center">418.56</td></tr><tr><td style="text-align:center">CUDA</td><td style="text-align:center">9.0</td></tr><tr><td style="text-align:center">Conda</td><td style="text-align:center">4.84</td></tr></tbody></table></div><h3 id="2-安装过程"><a href="#2-安装过程" class="headerlink" title="2. 安装过程"></a>2. 安装过程</h3><p>逐行运行下列命令即可，按照<a href="https://detectron2.readthedocs.io/tutorials/install.html">官方文档</a>运行的时候，发现少了<code>opencv-python</code>库，因此补了一条。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda create -n detectron2 python&#x3D;3.6</span><br><span class="line">conda activate detectron2</span><br><span class="line">conda install pytorch torchvision cudatoolkit&#x3D;9.2 -c pytorch</span><br><span class="line">pip install opencv-python</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;facebookresearch&#x2F;detectron2.git</span><br><span class="line">python -m pip install -e detectron2</span><br></pre></td></tr></table></figure><h3 id="3-Demo测试"><a href="#3-Demo测试" class="headerlink" title="3. Demo测试"></a>3. Demo测试</h3><h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><p>提前找一张图片放进<code>demo</code>文件夹中，这里从<a href="http://www.gudaimi.com/Sjfyltu/201812/99590.html">网络</a>随机照了一张图片，保存的文件名为 <code>test_pic.jpg</code>，结果并保存为同目录下的<code>res_pic.jpg</code> (<code>--output</code> 后的参数)；如果要测试视频，输出参数要将<code>--input</code> 改为<code>--video-input</code>。其余参数可以使用<code>python demo.py -h</code> 进行查看。</p><h4 id="3-2-代码运行"><a href="#3-2-代码运行" class="headerlink" title="3.2 代码运行"></a>3.2 代码运行</h4><p>进入<code>demo</code>文件夹测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd dtectron2&#x2F;demo</span><br><span class="line">python demo.py --config-file ..&#x2F;configs&#x2F;COCO- InstanceSegmentation&#x2F;mask_rcnn_R_50_FPN_3x.yaml \</span><br><span class="line">--input test_pic.jpg --output res_pic.jpg --opts MODEL.WEIGHTS \</span><br><span class="line">detectron2:&#x2F;&#x2F;COCO-InstanceSegmentation&#x2F;mask_rcnn_R_50_FPN_3x&#x2F;137849600&#x2F;model_final_f10217.pkl</span><br></pre></td></tr></table></figure><h5 id="3-2-1-输入"><a href="#3-2-1-输入" class="headerlink" title="3.2.1 输入"></a>3.2.1 输入</h5><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/test_pic.jpeg" alt="输入图像"></p><h5 id="3-2-2-结果"><a href="#3-2-2-结果" class="headerlink" title="3.2.2 结果"></a>3.2.2 结果</h5><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/res_pic.jpg" alt="测试结果"></p><p>到这里就完成了Detectron2的全部安装过程了，明天开始阅读demo.py文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/facebookresearch/detectron2&quot;&gt;Detectron2&lt;/a&gt; 是Facebook AI Research (FAIR)开源的目标检测框架，在上一代的基础上，基于Pytorch进行了实现。模型涵盖目标检测的Faster R-CNN, RetinaNet, 实例分割的Mask R-CNN, 关键点估计的Dense Pose, 全景分割的Panoptic FPN等多个模型，以及相应数据的加载等。&lt;/p&gt;
&lt;p&gt;最近在自己的项目实现过程，深刻意识到设计一个系统与解决一道代码题目是两个不同的概念。正好项目中需要用到Detectron2的部分代码，因此将Detectron2作为自己学习代码规范和项目实现的样例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="codes" scheme="http://www.yvesxu.com/categories/codes/"/>
    
    
      <category term="深度学习" scheme="http://www.yvesxu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://www.yvesxu.com/tags/pytorch/"/>
    
      <category term="源码阅读" scheme="http://www.yvesxu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="目标检测" scheme="http://www.yvesxu.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
      <category term="框架学习" scheme="http://www.yvesxu.com/tags/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>蝉鸣低语</title>
    <link href="http://www.yvesxu.com/2020/06/30/2020060-gossip-001/"/>
    <id>http://www.yvesxu.com/2020/06/30/2020060-gossip-001/</id>
    <published>2020-06-30T10:15:24.000Z</published>
    <updated>2020-11-07T07:32:18.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>十七年的蛰伏，只为一个盛夏，只为这个盛夏。</p><p>无人的深夜，从地下钻出。这并不是第一次看见这个世界，上一次不过是十七年前，出生后的匆匆一瞥。现在，依旧无暇关注，因为还有更重要的事情等着我。爬上树梢，准备开启生命中的最后一个阶段。在原来的身体里挣扎着，感受着躯壳撕裂开来，一点一点的剥离开来。相同的事情，已经经历了四次，现如今看着褪下的身躯，感叹着这是最后一次了，终于到最后一次了，梦想化作双翼。至此，总算拥有了生命，与灵魂契合的生命。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>自己的身份证快要过期了，下一张的有效期便是二十年。大哥自成年之后，即将走上奔三的生涯。终于是到了这个失去的年纪，不论是自己的亲人，抑或是崇拜的偶像，从霍金到张守晟，从金庸到斯坦·李，那些为人类科学事业不断奉献的人，那些伴随着自己成长的角色，终究都成了过往。</p><p>自从大学毕业之后，时间过得飞快。不记得哪一天开始，不怎么找歌听了，觉得现在列表里的就不错。也追不上新番了，仿佛中二病，黑子的篮球还是去年的番，夏目友人帐第五季，也不过是刚出的消息。最近买来的游戏，静静的躺在那里，看完了游戏启动画面，就再也没有然后。或许只是出于情怀喜+1吧，半开玩笑的说着“自己花钱买的游戏，凭什么还要花时间玩”，心里却多少有些落寞。遇到事情，不论好坏，也不愿去多谈什么，只是默默放在心底。</p><p>回首过去，才发觉忙忙碌碌，却什么都没有做。学了很多，却又什么都没有记住。人生实苦，于我而言，生命本身是没有意义的，更多的是寻找意义的过程，以及这一生中，不论悲喜，给自己留下的感觉。</p><p>未来，我如果有一个孩子，我不指望他能达成多大的成就，不求大富大贵，不求功名显赫。但是我想在灿烂星河下讲着牛郎织女的故事，说着奥林匹斯山上众神的纷争，告诉他阿基米德撬动地球的支点，以及梵高笔下的星夜。希望他能够领略浩瀚宇宙中的美景，更希望他能够被那一段段深情的文字所打动，为科学的公式所折服，为艺术的升华所感染。在万家灯火中，体验人间冷暖，学会感恩，懂得体谅。终于，他觉得无愧此生，平静坦然地按自己的计划过完余生。</p><p>可是孩子终究是独立的个体，本不应该按照我设定的路线走下去。这个世界，有太多的不如意，带他来到这个世界，或许就已经亏欠他太多了。直到朋友说起，这可能也是你想成为的人吧。那一刻，才意识到，原来这是自己想要成为的样子啊。自己终究不能免俗，将自己未完成的事情，寄希望于自己的孩子，更可笑的是自己还不自知。又或许是自己早早的框定了自己的余生，已经没有去戍守边疆，保家卫国，若是用尽全力，去做一些事情，做成一些事情，就很好了。</p><p>关于余生，我总需要一个出口。筹划了很久的博客，总算在今年提上了日程，记下人间的美好，存下自己的呢喃，也为自己的盛夏蛰伏。故此，蝉鸣。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;十七年的蛰伏，只为一个盛夏，只为这个盛夏。&lt;/p&gt;
&lt;p&gt;无人的深夜，从地下钻出。这并不是第一次看见这个世界，上一次不过是十七年前，出生后的匆匆一瞥。现在，依旧无暇关注，因为还有更重要的事情等着我。爬上树梢，准备开启生命中的最后一个阶段。在原来的身体里挣扎着，感受着躯壳撕裂开来，一点一点的剥离开来。相同的事情，已经经历了四次，现如今看着褪下的身躯，感叹着这是最后一次了，终于到最后一次了，梦想化作双翼。至此，总算拥有了生命，与灵魂契合的生命。&lt;/p&gt;
    
    </summary>
    
    
      <category term="thoughts" scheme="http://www.yvesxu.com/categories/thoughts/"/>
    
    
      <category term="人间值得" scheme="http://www.yvesxu.com/tags/%E4%BA%BA%E9%97%B4%E5%80%BC%E5%BE%97/"/>
    
  </entry>
  
</feed>
