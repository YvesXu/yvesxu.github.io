<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YvesXu</title>
  
  <subtitle>技术 · 生活 · 人间值得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yvesxu.com/"/>
  <updated>2020-09-11T09:44:11.858Z</updated>
  <id>http://www.yvesxu.com/</id>
  
  <author>
    <name>YvesXu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>detectron2 源码阅读系列 02 Demo.py</title>
    <link href="http://www.yvesxu.com/2020/09/10/20200911-detectron2-02-demo/"/>
    <id>http://www.yvesxu.com/2020/09/10/20200911-detectron2-02-demo/</id>
    <published>2020-09-10T14:12:52.000Z</published>
    <updated>2020-09-11T09:44:11.858Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇通过<code>demo.py</code>运行得到了一个检测的结果，这次深入到demo文件里面，分析整体框架的搭建。核心功能就是通过获取运行参数中的输入，进行结果预测，并输出可视化结果。<code>demo.py</code>的调用关系如下图所示</p><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/20200911_demo_frame.png" alt="demo结构"></p><h3 id="demo-py-文件概览"><a href="#demo-py-文件概览" class="headerlink" title="demo.py 文件概览"></a>demo.py 文件概览</h3><p>文件主要包含三个函数</p><ul><li>主函数</li><li><code>get_parser()</code></li><li><code>setup_cfg(args)</code></li></ul><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>总体流程</p><hr><ol><li><code>mp.set_start_method()</code>设置多线程操作</li><li><code>get_parser()</code> 函数获取参数，存入<code>args</code> </li><li><code>setup_logger()</code>函数设置日志文件</li><li><code>logger</code> 记录参数信息</li><li><code>setup_cfg(arg)</code> 将获取的参数进行设置，存入<code>cfg</code></li><li>创建<code>VisualizationDemo</code>类的实例为<code>demo</code></li><li>如果输入是图像<code>(args.input)</code></li><li>​    如果输入时单张图片:</li><li>​        确认指定路径下的文件存在</li><li>​    遍历<code>args.input</code>:</li><li>​        使用<code>read_image</code>读取路径下的图片</li><li>​        记录开始时间</li><li>​        调用<code>demo.run_on_image</code>得到预测结果<code>predictions</code>和可视化结果<code>visualized_output</code>，并记录日志信息（<code>predictions</code>预测到多少实例，预测花费时间）</li><li>​        如果需要保存结果<code>args.output</code>:</li><li>​            将可视化结果进行保存</li><li>​        否则利用窗口进行展示，按<code>esc</code>键退出</li><li>如果输入是网络摄像头<code>(args.webcam)</code>:</li><li>​    确认不包含图片输入<code>args.input</code>，且没有输出参数<code>args.output</code></li><li>​    设置摄像头为<code>cam</code>，并在上面运行<code>demo.run_on_video</code></li><li>​    针对每帧图片的预测结果，窗口显示1ms，按<code>esc</code>键退出，退出后释放网络摄像头，关闭所有窗口</li><li>如果输入是视频<code>(args.video_input)</code></li><li>​    将视频读进<code>video</code>，获取视频的尺寸信息<code>width</code>和<code>height</code>, 帧率<code>frames_per_second</code>，总帧数<code>num_frams</code>，</li><li>​    在<code>video</code>上运行<code>demo.run_on_video</code>，如果需要输出，则写入<code>output_file</code>，否则通过窗口显示结果，按<code>esc</code>键退出。运行后释放输入输出视频，关闭所有窗口。</li></ol><hr><h4 id="get-parser-函数"><a href="#get-parser-函数" class="headerlink" title="get_parser() 函数"></a><code>get_parser()</code> 函数</h4><p>这个函数的核心功能是利用系统的<code>argparse</code>模块进行参数解析，主要创建<code>ArgumentParser</code>对象，调用<code>.add_argument()</code>方法定义参数，使用<code>.parse_args()</code>进行参数解析三个步骤。第三个步骤在主函数里面调用，因此这个函数核心代码就只包含对象创建以及添加参数，最后返回<code>ArgumentParser</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parser</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument()</span><br></pre></td></tr></table></figure><p>这里添加的参数有</p><ul><li><code>--config-file</code> 配置文件位置</li><li><code>--webcam</code> 网络摄像头</li><li><code>--video-input</code> 视频路径</li><li><code>--input</code> 输入图片路径</li><li><code>--output</code> 可视化结果输出位置，如果为赋值，则通过窗口显示</li><li><code>--confidence-threshold</code> 显示实例预测的最小阈值</li><li><code>--opts</code> 其他可选配置</li></ul><h4 id="setup-cfg-args-函数"><a href="#setup-cfg-args-函数" class="headerlink" title="setup_cfg(args)函数"></a><code>setup_cfg(args)</code>函数</h4><p>前面<code>get_parser()</code> 函数返回的是一个参数解析器，主函数调用<code>.parse_args()</code>进行参数解析后得到<code>args</code>是一个<code>namespace</code>，指定了对应的配置文件，还需要将配置文件的参数进行解析。</p><p>首先构建了一个默认的<code>CfgNode</code>对象，主要用来存放基本的网络参数配置，通过调用<code>.merge_from_file()</code> 和 <code>.merge_from_list()</code>两个方法解析<code>args</code>的指定的配置文件，对默认数值进行更新。</p><h3 id="Predictor-py文件概览"><a href="#Predictor-py文件概览" class="headerlink" title="Predictor.py文件概览"></a><code>Predictor.py</code>文件概览</h3><p>从上面的总体流程中可以看出，<code>demo.py</code>的核心功能是通过<code>VisualizationDemo</code> 类实现的，这个类在同目录下的<code>predictor.py</code> 文件中。这个文件内部主要包含两个类：</p><ul><li><p><code>VisualizationDemo</code></p></li><li><p><code>AsyncPredictor</code>  </p></li></ul><h4 id="VisualizationDemo-类"><a href="#VisualizationDemo-类" class="headerlink" title="VisualizationDemo 类"></a><code>VisualizationDemo</code> 类</h4><p>内部定义了以下四个函数：</p><ul><li><code>__init__()</code></li><li><code>run_on_image()</code></li><li><code>run_on_video()</code></li><li><code>_frame_from_video()</code></li></ul><h5 id="init"><a href="#init" class="headerlink" title="__init__()"></a><code>__init__()</code></h5><p>定义了预测参数，并根据并行处理需求将<code>predictor</code>设置为默认预测器<code>DefaultPredictor</code>或者并行预测器<code>AsyncPredictor</code>。</p><h5 id="run-on-image-self-image"><a href="#run-on-image-self-image" class="headerlink" title="run_on_image(self, image)"></a><code>run_on_image(self, image)</code></h5><ul><li>输入：图像（H, W, C）图像模式 (BGR)</li><li>输出：网络输出结果<code>predictions</code>, 可视化结果<code>vis_output</code>，可视化结果是<code>Visualizer</code>对象。</li></ul><h5 id="frame-from-video-self-video"><a href="#frame-from-video-self-video" class="headerlink" title="_frame_from_video(self, video)"></a><code>_frame_from_video(self, video)</code></h5><p>获取视频帧</p><h5 id="run-on-video-self-video"><a href="#run-on-video-self-video" class="headerlink" title="run_on_video(self, video)"></a><code>run_on_video(self, video)</code></h5><p>调用<code>_frame_from_video</code> 方法获取视频帧，对每一帧进行预测，并通过内置的<code>process_predictions</code>方法，创建<code>Visualizer</code>对象，对结果进行展示。</p><h4 id="AsyncPredictor类"><a href="#AsyncPredictor类" class="headerlink" title="AsyncPredictor类"></a><code>AsyncPredictor</code>类</h4><p>主要是针对多GPU预测进行了处理，每个GPU上构建一个默认预测器<code>DefaultPredictor</code>，分别进行预测。</p><h4 id="DefaultPredictor-类"><a href="#DefaultPredictor-类" class="headerlink" title="DefaultPredictor 类"></a><code>DefaultPredictor</code> 类</h4><p>不论是单GPU，还是多GPU，最后的预测器都调用了<code>DefaultPredictor</code> 类，该类位于<code>detectron2\engine\defaults.py</code>中，内部只有初始化函数<code>__init__</code>和回调函数<code>__call__</code>，核心功能是通过给定参数构建端到端的网络，对输入图像进行<code>Transfrom</code>后，并送入网络模型，预测结果。</p><p>demo的功能浏览完了，接下去的内容会从<code>Dataloader</code>开始，构建模型，评估测试，最终结果可视化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇通过&lt;code&gt;demo.py&lt;/code&gt;运行得到了一个检测的结果，这次深入到demo文件里面，分析整体框架的搭建。核心功能就是通过获取运行参数中的输入，进行结果预测，并输出可视化结果。&lt;code&gt;demo.py&lt;/code&gt;的调用关系如下图所示&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
    
      <category term="detectron2" scheme="http://www.yvesxu.com/categories/detectron2/"/>
    
    
      <category term="源码阅读" scheme="http://www.yvesxu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://www.yvesxu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://www.yvesxu.com/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>detectron2 源码阅读系列 01 安装流程</title>
    <link href="http://www.yvesxu.com/2020/09/10/20200910-detectron2-01-installation/"/>
    <id>http://www.yvesxu.com/2020/09/10/20200910-detectron2-01-installation/</id>
    <published>2020-09-10T01:25:24.000Z</published>
    <updated>2020-09-11T09:43:22.812Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="https://github.com/facebookresearch/detectron2">Detectron2</a> 是Facebook AI Research (FAIR)开源的目标检测框架，在上一代的基础上，基于Pytorch进行了实现。模型涵盖目标检测的Faster R-CNN, RetinaNet, 实例分割的Mask R-CNN, 关键点估计的Dense Pose, 全景分割的Panoptic FPN等多个模型，以及相应数据的加载等。</p><p>最近在自己的项目实现过程，深刻意识到设计一个系统与解决一道代码题目是两个不同的概念。正好项目中需要用到Detectron2的部分代码，因此将Detectron2作为自己学习代码规范和项目实现的样例。</p><h3 id="主机环境"><a href="#主机环境" class="headerlink" title="主机环境"></a>主机环境</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">版本</th></tr></thead><tbody><tr><td style="text-align:center">操作系统</td><td style="text-align:center">Linux 16.04</td></tr><tr><td style="text-align:center">显卡</td><td style="text-align:center">GTX Titan X</td></tr><tr><td style="text-align:center">驱动</td><td style="text-align:center">418.56</td></tr><tr><td style="text-align:center">CUDA</td><td style="text-align:center">9.0</td></tr><tr><td style="text-align:center">Conda</td><td style="text-align:center">4.84</td></tr></tbody></table></div><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>逐行运行下列命令即可，按照<a href="https://detectron2.readthedocs.io/tutorials/install.html">官方文档</a>运行的时候，发现少了<code>opencv-python</code>库，因此补了一条。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">conda create -n detectron2 python&#x3D;3.6</span><br><span class="line">conda activate detectron2</span><br><span class="line">conda install pytorch torchvision cudatoolkit&#x3D;9.2 -c pytorch</span><br><span class="line">pip install opencv-python</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;facebookresearch&#x2F;detectron2.git</span><br><span class="line">python -m pip install -e detectron2</span><br></pre></td></tr></table></figure><h3 id="Demo测试"><a href="#Demo测试" class="headerlink" title="Demo测试"></a>Demo测试</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>提前找一张图片放进<code>demo</code>文件夹中，这里从<a href="http://www.gudaimi.com/Sjfyltu/201812/99590.html">网络</a>随机照了一张图片，保存的文件名为 <code>test_pic.jpg</code>，结果并保存为同目录下的<code>res_pic.jpg</code> (<code>--output</code> 后的参数)；如果要测试视频，输出参数要将<code>--input</code> 改为<code>--video-input</code>。其余参数可以使用<code>python demo.py -h</code> 进行查看。</p><h4 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h4><p>进入<code>demo</code>文件夹测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd dtectron2&#x2F;demo</span><br><span class="line">python demo.py --config-file ..&#x2F;configs&#x2F;COCO- InstanceSegmentation&#x2F;mask_rcnn_R_50_FPN_3x.yaml \</span><br><span class="line">--input test_pic.jpg --output res_pic.jpg --opts MODEL.WEIGHTS \</span><br><span class="line">detectron2:&#x2F;&#x2F;COCO-InstanceSegmentation&#x2F;mask_rcnn_R_50_FPN_3x&#x2F;137849600&#x2F;model_final_f10217.pkl</span><br></pre></td></tr></table></figure><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/test_pic.jpeg" alt="输入图像"></p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="http://hexotuchuang.oss-cn-beijing.aliyuncs.com/blog_init/post/detectron2/res_pic.jpg" alt="测试结果"></p><p>到这里就完成了Detectron2的全部安装过程了，明天开始阅读demo.py文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/facebookresearch/detectron2&quot;&gt;Detectron2&lt;/a
      
    
    </summary>
    
    
      <category term="detectron2" scheme="http://www.yvesxu.com/categories/detectron2/"/>
    
    
      <category term="源码阅读" scheme="http://www.yvesxu.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="深度学习" scheme="http://www.yvesxu.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="pytorch" scheme="http://www.yvesxu.com/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>蝉鸣低语</title>
    <link href="http://www.yvesxu.com/2020/06/30/gossip_001/"/>
    <id>http://www.yvesxu.com/2020/06/30/gossip_001/</id>
    <published>2020-06-30T10:15:24.000Z</published>
    <updated>2020-08-18T05:54:23.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>十七年的蛰伏，只为一个盛夏，只为这个盛夏。</p><p>无人的深夜，从地下钻出。这并不是第一次看见这个世界，上一次不过是十七年前，出生后的匆匆一瞥。现在，依旧无暇关注，因为还有更重要的事情等着我。爬上树梢，准备开启生命中的最后一个阶段。在原来的身体里挣扎着，感受着躯壳撕裂开来，一点一点的剥离开来。相同的事情，已经经历了四次，现如今看着褪下的身躯，感叹着这是最后一次了，终于到最后一次了，梦想化作双翼。至此，总算拥有了生命，与灵魂契合的生命。</p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>自己的身份证快要过期了，下一张的有效期便是二十年。大哥自成年之后，即将走上奔三的生涯。终于是到了这个失去的年纪，不论是自己的亲人，抑或是崇拜的偶像，从霍金到张守晟，从金庸到斯坦·李，那些为人类科学事业不断奉献的人，那些伴随着自己成长的角色，终究都成了过往。</p><p>自从大学毕业之后，时间过得飞快。不记得哪一天开始，不怎么找歌听了，觉得现在列表里的就不错。也追不上新番了，仿佛中二病，黑子的篮球还是去年的番，夏目友人帐第五季，也不过是刚出的消息。最近买来的游戏，静静的躺在那里，看完了游戏启动画面，就再也没有然后。或许只是出于情怀喜+1吧，半开玩笑的说着“自己花钱买的游戏，凭什么还要花时间玩”，心里却多少有些落寞。遇到事情，不论好坏，也不愿去多谈什么，只是默默放在心底。</p><p>回首过去，才发觉忙忙碌碌，却什么都没有做。学了很多，却又什么都没有记住。人生实苦，于我而言，生命本身是没有意义的，更多的是寻找意义的过程，以及这一生中，不论悲喜，给自己留下的感觉。</p><p>未来，我如果有一个孩子，我不指望他能达成多大的成就，不求大富大贵，不求功名显赫。但是我想在灿烂星河下讲着牛郎织女的故事，说着奥林匹斯山上众神的纷争，告诉他阿基米德撬动地球的支点，以及梵高笔下的星夜。希望他能够领略浩瀚宇宙中的美景，更希望他能够被那一段段深情的文字所打动，为科学的公式所折服，为艺术的升华所感染。在万家灯火中，体验人间冷暖，学会感恩，懂得体谅。终于，他觉得无愧此生，平静坦然地按自己的计划过完余生。</p><p>可是孩子终究是独立的个体，本不应该按照我设定的路线走下去。这个世界，有太多的不如意，带他来到这个世界，或许就已经亏欠他太多了。直到朋友说起，这可能也是你想成为的人吧。那一刻，才意识到，原来这是自己想要成为的样子啊。自己终究不能免俗，将自己未完成的事情，寄希望于自己的孩子，更可笑的是自己还不自知。又或许是自己早早的框定了自己的余生，已经没有去戍守边疆，保家卫国，若是用尽全力，去做一些事情，做成一些事情，就很好了。</p><p>关于余生，我总需要一个出口。筹划了很久的博客，总算在今年提上了日程，记下人间的美好，存下自己的呢喃，也为自己的盛夏蛰伏。故此，蝉鸣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;十七年的蛰伏，只为一个盛夏，只为这个盛夏。&lt;/p&gt;
&lt;p&gt;无人的深夜，从地下钻出。这并不是第一次看见这个世界，上一次不过是十七年前，出生后的
      
    
    </summary>
    
    
      <category term="gossip" scheme="http://www.yvesxu.com/categories/gossip/"/>
    
    
      <category term="人间值得" scheme="http://www.yvesxu.com/tags/%E4%BA%BA%E9%97%B4%E5%80%BC%E5%BE%97/"/>
    
  </entry>
  
</feed>
